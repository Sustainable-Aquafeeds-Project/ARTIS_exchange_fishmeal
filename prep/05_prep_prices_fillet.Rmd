---
title: "Prep ARTIS fishmeal data with accessory datasets"
output: html_document
date: "2024-08-01"
---

## Summary


## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(here)
library(tidyverse)
library(glue)
library(sf)
library(devtools)
library(janitor)
library(countrycode)
library(qs)

source(here("R/directories.R"))

full_artis <- qs::qread(file.path(artis_dir, "full_artis_fm_fillet.qs"))

# get fishmeal info
fm_artis <- full_artis %>% 
  filter(hs6 == 230120)

# get fillet info
fillet_artis <- full_artis %>%
  filter(hs6 != 230120)


artis_taxa <- read.csv(file.path(artis_dir, "artis_full_data/data/attribute tables/sciname.csv")) ## read in attribute table with common names

countries <- read.csv(here("data/countries.csv")) ## artis countries with info

prices <- read.csv("/mnt/rdsi/raw_data/sea-around-us/ex-vessel-prices/outputFMFO2021-03-12.csv")
taxa <- read.csv("/mnt/rdsi/raw_data/sea-around-us/ex-vessel-prices/taxa.csv")

entity <- read.csv("/mnt/rdsi/raw_data/sea-around-us/ex-vessel-prices/fishing_entity.csv") %>%
  dplyr::select(-X) %>%
  mutate(iso3c = countrycode(sourcevar = name, origin = "country.name", destination = "iso3c"))

## get artis data matched with sustainability reports (not yet gapfilled)
artis_trimmings_all <- read.csv(file.path(artis_dir, "artis_exchange/artis_fishmeal_trimmings_not_gf.csv"))


```

Classify ARTIS data into fillets or not filleted species

```{r}
fillet_data <- fillet_artis %>% 
  filter(live_weight_t > 0) %>% # just to be sure
  distinct(year, source_country_iso3c, sciname) %>%
  mutate(filleted = "yes") 
# %>%
#   group_by(year, source_country_iso3c, sciname) %>%
#   summarise(n())


artis_trimmings_fillet <- artis_trimmings_all %>% # for now we'll join on year and species
  left_join(fillet_data) %>%
  mutate(filleted = ifelse(is.na(filleted), "no", filleted))

test <- artis_trimmings_fillet %>%
  filter(filleted == "no", year == 2020)

sum(test$product_weight_t)/3494636 # ~21% product weight is NOT filleted.. that's not much! This means the majority of fishmeal comes from filleted species, which is counter to what I would imagine...

test <- artis_trimmings_fillet %>% 
  group_by(year, filleted) %>%
  summarise(product_weight_t = sum(product_weight_t, na.rm = TRUE)) %>%
  ungroup() # ok damn! 

test <- artis_trimmings_fillet %>%
  filter(!is.na(trimmings_gf)) %>%
  filter(year == 2020) %>%
  group_by(filleted) %>%
  summarise(trim = sum(trim_product,na.rm = TRUE), 
            whole = sum(wholefish_product, na.rm = TRUE)) 

## wow a pretty significant portion (~90%) of whole fish rendered fish meal is from species used for fillets, so maybe our assumption isn't right!! 
# ~70% of trimmings fish meal are also used as fillets, so that makes sense

```


Prep ex-vessel price data so that we can easily match to ARTIS data 

```{r}
prices_taxa <- prices %>% 
  left_join(., taxa, by = "TaxonKey") %>%
    clean_names() %>%
  left_join(., entity, by = "fishing_entity_id") %>%
  mutate(sciname = tolower(taxon_name),
         common_name = tolower(common_name)) %>%
  dplyr::select(year, source_country_iso3c = iso3c, sciname, year, price2010usd_mean, price2010usd_ci) %>%
  filter(!is.na(source_country_iso3c)) 


## lets look at the data we got from emlab
ex_vessel_updated <- read.csv(file.path(rdsi_raw_data_dir, "sea-around-us/ex-vessel-prices/exvessel_price_database_1976_2019.csv")) %>%
  dplyr::select(-X) %>%
  clean_names() %>%
  group_by(scientific_name, year) %>%
  summarise(q90 = quantile(exvessel, 0.9, na.rm = TRUE),
            avg_price = mean(exvessel, na.rm = TRUE)) %>%
  ungroup() %>% 
  mutate(price = ifelse(q90 != avg_price, q90, avg_price)) %>% # some species have multiple prices, so we will take the 90th quantile if there are multiple, otherwise, the mean (which is just the price, because these only have 1 observation)
  dplyr::select(sciname = scientific_name, year, price) %>%
  mutate(sciname = tolower(sciname))

# Step 1: Add 2020 for each sciname with a 2019 observation

add_row_price <- ex_vessel_updated %>%
  filter(year == 2019) %>%
  mutate(year = 2020)


ex_vessel_fill_1 <- ex_vessel_updated %>%
  rbind(., add_row_price)

# Step 2: Fill missing prices between 1976 and 2019
ex_vessel_filled <- ex_vessel_fill_1 %>%
  group_by(sciname) %>%
  arrange(year) %>%
  mutate(price = na.locf(price, na.rm = FALSE)) %>%
  mutate(price = na.locf(price, fromLast = TRUE, na.rm = FALSE)) %>%
  ungroup() %>%
  filter(!is.na(year)) %>%
  filter(!is.na(price)) %>%
  mutate(sciname = str_remove_all(sciname, " spp")) %>% # remove spp from sciname as ARTIS does not have these
  mutate(sciname = case_when(
    sciname == "clupeoidei" ~ "clupeidae",
    sciname == "scombroidei" ~ "scombrinae",
    sciname == "salmonoidei" ~ "salmonidae",
    TRUE ~ sciname)) # fill suborder with subfamily prices, since subfamily is in ARTIS


```

We are still missing around 392 species in the ARTIS data that don't have prices. We will gapfill the one word species that don't match (i.e., their genus) to the average of all species in that genus that are in the price data.


```{r}
ex_vessel_taxa <- ex_vessel_filled %>%
  distinct(sciname)

missing_taxa <- data.frame(sciname= setdiff(unique(ex_vessel_taxa$sciname), unique(artis_trimmings_fillet$sciname))) # 453 spp
missing_taxa_artis <- data.frame(sciname=setdiff(unique(artis_trimmings_fillet$sciname), unique(ex_vessel_taxa$sciname))) # 392 spp

## ok lets get the one word taxa from artis and vessel prices and compare


# Filter strings that only contain one word (no spaces)
one_word_artis <- data.frame(sciname = missing_taxa_artis$sciname[!str_detect(missing_taxa_artis$sciname, "\\s")])

one_word_prices <- data.frame(sciname = missing_taxa$sciname[!str_detect(missing_taxa$sciname, "\\s")])

# unique(one_word_artis$sciname)
# 
# unique(one_word_prices$sciname)

## ok so I need to filter for any species in the ex vessel data which contain the one word artis species, extract those as their sciname, group by sciname and year, and take an average price

pattern <- paste(unique(one_word_artis$sciname), collapse = "|")

ex_vessel_oneword_fill <- ex_vessel_filled %>%
  mutate(first_word = word(sciname, 1),  # Extract the first word
         matched_word = str_extract(first_word, pattern)) %>%
  filter(!is.na(matched_word)) %>%
    filter(first_word %in% unique(one_word_artis$sciname)) %>%  # Filter for exact matches
  group_by(matched_word, year) %>%
  summarise(price = mean(price, na.rm = TRUE)) %>%
  ungroup() %>%
  rename(sciname = matched_word)

ex_vessel_filled_2 <- rbind(ex_vessel_filled, ex_vessel_oneword_fill)

# see what is missing now - we only care about the missing ARTIS spp
ex_vessel_taxa <- ex_vessel_filled_2 %>%
  distinct(sciname)

missing_taxa <- data.frame(sciname= setdiff(unique(ex_vessel_taxa$sciname), unique(artis_trimmings_fillet$sciname))) # 453 spp
missing_taxa_artis <- data.frame(sciname=setdiff(unique(artis_trimmings_fillet$sciname), unique(ex_vessel_taxa$sciname))) # 360 spp

## i think i'll need to gapfill these with congeneric species? So I will need to get their high order taxanomic info and make averages from those. ARTIS has that info

artis_trimmings_fillet_prices <- artis_trimmings_fillet %>%
  left_join(ex_vessel_filled_2) %>%
  distinct()

test <- artis_trimmings_fillet_prices %>%
  filter(is.na(price))

nrow(test)/nrow(artis_trimmings_fillet_prices) # ok.. this is a lot better! Only missing prices for ~13% of observations... There is definitely some gapfilling i can do... will gapfill based on higher order taxanomic information, like they do in Butt et al trait paper

```

360 species in the ARTIS data still do not have price data:

Gapfill price data with averages from congeneric species; start with lowest level taxa info and move up to higher orders

```{r}

artis_prices_gf <- artis_trimmings_fillet_prices %>%
  group_by(genus) %>%
  mutate(genus_mean_price_gf = mean(price, na.rm = TRUE)) %>%
  ungroup() %>%
  group_by(family) %>%
  mutate(family_mean_price_gf = mean(price, na.rm = TRUE)) %>%
  ungroup() %>%
  group_by(order) %>%
  mutate(order_mean_price_gf = mean(price, na.rm = TRUE)) %>%
  ungroup() %>%
  group_by(class) %>%
  mutate(class_mean_price_gf = mean(price, na.rm = TRUE)) %>%
  ungroup() %>%
   mutate(price_gf = 
           case_when(is.na(price) & !is.na(genus_mean_price_gf) ~ genus_mean_price_gf,
                     is.na(price) & is.na(genus_mean_price_gf) & !is.na(family_mean_price_gf) ~ family_mean_price_gf, 
                     is.na(price) & is.na(genus_mean_price_gf) & is.na(family_mean_price_gf) & !is.na(order_mean_price_gf) ~ order_mean_price_gf,
                     is.na(price) & is.na(genus_mean_price_gf) & is.na(family_mean_price_gf) & is.na(order_mean_price_gf) & !is.na(class_mean_price_gf) ~ class_mean_price_gf,
                     TRUE ~ price
                     )) %>%
     mutate(gapfill_flag_price = 
           case_when(is.na(price) & !is.na(genus_mean_price_gf) ~ "genus",
                     is.na(price) & is.na(genus_mean_price_gf) & !is.na(family_mean_price_gf) ~ "family", 
                     is.na(price) & is.na(genus_mean_price_gf) & is.na(family_mean_price_gf) & !is.na(order_mean_price_gf) ~ "order",
                     is.na(price) & is.na(genus_mean_price_gf) & is.na(family_mean_price_gf) & is.na(order_mean_price_gf) & !is.na(class_mean_price_gf) ~ "class",
                     TRUE ~ "none"
                     )) %>%
  dplyr::select(hs_version, year, source_country_iso3c, exporter_iso3c, importer_iso3c, dom_source, sciname, habitat, method, product_weight_t, live_weight_t, common_name, trim_prop_gf_flag = method_gf, trimmings_gf, wholefish_gf, trim_prop_gf, filleted, price_gf, gapfill_flag_price)

test <- artis_prices_gf %>%
  filter(is.na(price_gf))

test <- artis_prices_gf %>%
  group_by(gapfill_flag_price) %>%
  summarise(n = n()) %>%
  ungroup()

## Perfect its all filled now


qs::qsave(artis_prices_gf, here("int/artis_trimmings_fillet_prices.qs")) # wow ~4 million rows only 83 MB!


```





