---
title: "Gapfill with simple assumptions"
output: html_document
date: "2024-08-01"
editor_options: 
  chunk_output_type: console
---

## Summary

## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(here)
library(tidyverse)
library(glue)
library(sf)
library(devtools)
library(janitor)
library(countrycode)
library(qs)

source(here("R/directories.R"))

full_artis <- qs::qread(file.path(artis_dir, "full_artis_fm_fillet.qs"))

fillet_artis <- full_artis %>%
  filter(hs6 != 230120) %>%
  dplyr::select(-hs_version) %>% # don't need this
  rename(consumer_iso3c = importer_iso3c) # just to make things consistent

fm_artis <- qs::qread(file.path(artis_dir, "full_artis_fm_2024_09_19.qs")) %>%
  mutate(hs6 = 230120,
         dom_source = ifelse(dom_source == "", consumption_type, dom_source)) %>%
  dplyr::select(year, source_country_iso3c, exporter_iso3c, consumer_iso3c, dom_source, hs6, sciname, habitat, method, product_weight_t, live_weight_t = consumption_t_capped) %>%
  mutate(exporter_iso3c = ifelse(source_country_iso3c == consumer_iso3c, source_country_iso3c, exporter_iso3c))

setdiff(colnames(fillet_artis), colnames(fm_artis))
setdiff(colnames(fm_artis), colnames(fillet_artis)) # 0 good

artis_taxa <- read.csv(file.path(artis_dir, "artis_full_data/data/attribute tables/sciname.csv")) ## read in attribute table with common names
countries <- read.csv(here("data/countries.csv")) ## artis countries with info

artis_comm_sci <- artis_taxa %>%
  distinct(common_name, sciname)
```

Read in FM origins data 

```{r}
fm_origins_df_fin <- read.csv(here("outputs/all_fmfo_material_origins_literature.csv")) %>%
  dplyr::select(-common_name) %>%
  group_by(sciname, iso3c, capture) %>%
  summarise(trim_prop = mean(trim_prop, na.rm = TRUE)) %>%
  ungroup()

fm_origins_traded <- read.csv(here("outputs/feed_company_fmfo_material_origins_traded.csv")) %>%
  dplyr::select(-common_name) %>%
  group_by(sciname, source_country_iso3c, importer_iso3c, capture) %>%
  summarise(trim_prop = mean(trim_prop, na.rm = TRUE)) %>%
  ungroup()

ggplot(fm_origins_traded) +
  geom_histogram(aes(trim_prop)) +
  theme_bw() +
  labs(x = "Proportion of fishmeal derived from trimmings",
       y = "Distinct species and source country count")


# take a look at the distribution of values
ggplot(fm_origins_df_fin) +
  geom_histogram(aes(trim_prop)) +
  theme_bw() +
  labs(x = "Proportion of fishmeal derived from trimmings",
       y = "Distinct species and source country count")


fm_origins_df_test <- read.csv(here("outputs/all_fmfo_material_origins_literature.csv")) %>%
  dplyr::select(-common_name) %>%
  group_by(sciname, capture) %>%
  summarise(trim_prop = mean(trim_prop, na.rm = TRUE)) %>%
  ungroup()

# take a look at the distribution of values
ggplot(fm_origins_df_test) +
  geom_histogram(aes(trim_prop)) +
  theme_bw() +
  labs(x = "Proportion of fishmeal derived from trimmings",
       y = "Distinct species and source country count") # greater species diversity in trimmings, makes sense
```

Join feed company traded data to ARTIS data by sciname, origin iso3c, and importer iso3c

```{r}
artis_trimmings_all <- fm_artis %>%
  left_join(fm_origins_traded, by = c("sciname", "source_country_iso3c", "exporter_iso3c" = "importer_iso3c")) # match to exporter_iso3c since those are the processing countries, and the "importer_iso3c" represents the factory locations for the feed companies

# filter for the non-NA info from that join 
artis_trimmings_info_traded <- artis_trimmings_all %>%
    filter(!is.na(trim_prop)) %>%
  mutate(
         trim_prop_gf = trim_prop) %>%
   ## fix some (rare) instances when method is aquaculture but our info is capture and they are matching. Just make these NA
  mutate(
         trim_prop_gf = case_when(
            method == "aquaculture" & capture == "yes" & !is.na(trim_prop_gf) ~ NA,
            TRUE ~ trim_prop_gf
         )
  )

summary(artis_trimmings_info_traded)

# since we added some NAs we need to filter for those now
missing_from_traded_df <- artis_trimmings_info_traded %>%
  filter(is.na(trim_prop_gf)) 


artis_trimmings_info_traded_fin <- artis_trimmings_info_traded %>%
  filter(!is.na(trim_prop_gf)) %>% # make sure
  mutate(method_trim_gf = "none; filled using company reports from source to processing country")

nrow(artis_trimmings_info_traded)-nrow(missing_from_traded_df) == nrow(artis_trimmings_info_traded_fin) # TRUE - good

## now we have artis_trimmings_info_traded_fin as one of our final dfs; no gapfilling required for these rows 

# # how much fishmeal? 


test <- artis_trimmings_info_traded_fin %>%
  filter(!is.na(trim_prop_gf),
         year == 2020) %>%
  pull(product_weight_t) %>%
  sum()

artis_trimmings_all %>%
  filter(year == 2020) %>%
  pull(product_weight_t) %>%
  sum()

test/6158133 # got about 11% of fishmeal 2020 this way! That's pretty good!  
```


```{r}
# now get all of the trim_prop NAs after joining to the feed company trade data 

# filter the original joined data for NA trim prop and join with the other NAs we designated ourselves. 
# then join with our source information from literature
artis_trimmings_basic_sources <- artis_trimmings_all %>%
  filter(is.na(trim_prop)) %>%
  mutate(trim_prop_gf = trim_prop) %>%  
  rbind(., missing_from_traded_df) %>% 
    mutate(method_new = ifelse(method == "aquaculture", "aquaculture", "capture")) %>% 
  dplyr::select(-trim_prop, -capture, -trim_prop_gf) %>%
  left_join(fm_origins_df_fin %>% mutate(method_new = ifelse(capture == "yes", "capture", "aquaculture")), by = c("sciname", "source_country_iso3c" = "iso3c", "method_new")) # I'm not sure what is duplicating? 

summary(artis_trimmings_basic_sources)

test <- artis_trimmings_basic_sources %>%
  left_join(artis_taxa) %>%
  filter(phylum == "mollusca", 
         common_name == "common squids nei",
         source_country_iso3c == "VNM"
  )
# filter for non-na trim_prop_gf
artis_trimmings_info_sources <- artis_trimmings_basic_sources %>% 
  filter(!is.na(trim_prop)) %>% # filter for non-na
  mutate(
         trim_prop_gf = trim_prop) %>%
  mutate(
        trim_prop_gf = ifelse(source_country_iso3c == "MEX" & sciname == "thunnus albacares", 1, trim_prop_gf)) %>%  # fix the mexico yellowfin tuna instance
  ## fix some (rare) instances when method is aquaculture but our info is capture and they are matching. Just make these NA
  mutate(trim_prop_gf = case_when(
            method == "aquaculture" & capture == "yes" & !is.na(trim_prop_gf) ~ NA,
            TRUE ~ trim_prop_gf
         ),
         method_trim_gf = "none; filled using values from literature") %>%
  distinct()

missing <- artis_trimmings_info_sources %>% 
  filter(is.na(trim_prop_gf)) # ok cool none missing 

# now filter for the remainder that we need to fix
artis_trimmings_info_to_fix <- artis_trimmings_basic_sources %>%
  mutate(trim_prop_gf = trim_prop) %>%
  mutate(method_trim_gf = NA) %>%
  filter(is.na(trim_prop_gf)) %>%
  distinct()

nrow(artis_trimmings_info_to_fix) + nrow(artis_trimmings_info_sources) + nrow(artis_trimmings_info_traded_fin) == nrow(fm_artis) # TRUE

artis_trimmings_all_info <- artis_trimmings_info_sources %>%
  dplyr::select(-method_new) %>%
  rbind(., artis_trimmings_info_traded_fin) %>%
  dplyr::select(-trim_prop) # ok this is all the non-gapfilled data from our literature review


tonnes_lit <- artis_trimmings_all_info %>% 
  filter(year == 2020) %>%
  pull(product_weight_t) %>%
  sum()

tonnes_lit/fm_artis %>% filter(year == 2020) %>% pull(product_weight_t) %>% sum() # 0.3593609 ~ 36% matching. How does that compare to before? Before was 40%, because we used the average from both the literature and reports. Should we try that now for some gapfilling? 



tonnes_lit <- artis_trimmings_info_sources %>% 
  filter(year == 2020) %>%
  pull(product_weight_t) %>%
  sum()

tonnes_lit/fm_artis %>% filter(year == 2020) %>% pull(product_weight_t) %>% sum() # 0.2531985 ~ 25% matching.

``` 

Now we need to gapfill the missing information 

First we will average the trimmings info from the company reports and the literature and see if we fill anymore. 

```{r}
mean_reports_literature <- fm_origins_traded %>%
  group_by(sciname, source_country_iso3c, capture) %>%
  summarise(trim_prop = mean(trim_prop, na.rm = TRUE)) %>%
  ungroup() %>%
  rbind(., fm_origins_df_fin %>%
          rename(source_country_iso3c = iso3c)) %>%
  group_by(sciname, source_country_iso3c, capture) %>%
  summarise(trim_prop = mean(trim_prop, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(method_new = ifelse(capture == "yes", "capture", "aquaculture"))


artis_trimmings_info_to_fix_1 <- artis_trimmings_info_to_fix %>%
  dplyr::select(colnames(fm_artis), method_new) %>%
  left_join(., mean_reports_literature)


artis_trimmings_info_fixed_1 <- artis_trimmings_info_to_fix_1 %>%
  filter(!is.na(trim_prop)) %>%
  rename(trim_prop_gf = trim_prop) %>%
  mutate(method_trim_gf = "Average trimmings proportion of source country and species from all literature and reports")


artis_trimmings_all_info_1 <- artis_trimmings_all_info %>%
  rbind(., artis_trimmings_info_fixed_1 %>% dplyr::select(colnames(artis_trimmings_all_info)))

artis_trimmings_all_info_1 %>% 
  filter(year == 2020) %>%
  pull(product_weight_t) %>%
  sum()/fm_artis %>% filter(year == 2020) %>% pull(product_weight_t) %>% sum() # 0.4012084 ~ 40% matching. Cool, the mean gapfilling fills ~4% for 2020

artis_trimmings_info_to_fix_2 <- artis_trimmings_info_to_fix_1 %>%
  filter(is.na(trim_prop))
 
nrow(artis_trimmings_info_to_fix_2) + nrow(artis_trimmings_all_info_1) == nrow(fm_artis) # TRUE good 

# some checking
test_all <- artis_trimmings_all_info_1 %>%
  filter(year == 2020) %>%
  mutate(trim_weight = product_weight_t*trim_prop_gf,
         whole_weight = product_weight_t*(1-trim_prop_gf))

test_weight_2020 <- fm_artis %>% filter(year == 2020) %>% pull(product_weight_t) %>% sum() # 6158133
test_trim <- sum(test_all$trim_weight, na.rm = TRUE) # 784463.1
test_whole <- sum(test_all$whole_weight, na.rm = TRUE) # 1686232

test_whole/test_weight_2020 # 27% from whole fish 
test_trim/test_weight_2020 # 12.7% from trimmings
# if that scales then that is about 60-40 whole fish to trimmings. It won't scale tho. 
```

Next we need to gapfill the rest. I propose:
 - first we will assume any aquaculture is trimmings, based on information from Shea et al. and general common sense...
 - matching trade flows with fillets. If a fillet has the same sciname, source country, and exporter/processing country as fishmeal, then we will assume it is trimmings. 
 - Then we will do sciname level averages 
 - Then we will do general assumptions (see below)
 - Then we will do price gapfilling 
 
 
 Assume that any aquaculture is trimmings
  - RESULT: This fills ~33% of fishmeal without info for 2020 (mostly shrimp aquaculture)

```{r}
# read in shea et al raw data
fmfo_factory_data <- read.csv(here("data/shea_et_al_FMFO/adr6921_Suppl_Excel_v2.csv")) %>%
filter(!is.na(factory_id)) %>%
  mutate(country = str_replace_all(country, "\u00A0", " ")) %>%
  filter(str_detect(material_type, "aquaculture"))
unique(fmfo_factory_data$material_type_simple)
# ok so any materials with aquaculutre in the name are by products. 
## additionally backed up for finfish by these sources:   # finfish aquaculture = trimmings: skretting report, Ytrestroyl et al. 2015, Xu and Ming 2018, Penarubia et al. 2023
## farmed shrimp backed up by this :       # IFFO report; https://link.springer.com/book/10.1007/978-94-011-4018-8
# From https://www.iffo.com/by-product; "[2] In this analysis we are not including the large volume of farmed shrimp waste, which does not yield any oil but only meal."



artis_trimmings_aquaculture <- artis_trimmings_info_to_fix_2 %>%
  mutate(trim_prop_gf = ifelse(is.na(trim_prop) & method == "aquaculture", 1, trim_prop))

nrow(artis_trimmings_aquaculture) == nrow(artis_trimmings_info_to_fix_2)

  artis_trimmings_aquaculture_gf <- artis_trimmings_aquaculture %>%
    filter(!is.na(trim_prop_gf)) %>%
     mutate(method_trim_gf = "Assuming trimmings because production method is aquaculture") 


artis_trimmings_info_to_fix_3 <- artis_trimmings_aquaculture %>%
  filter(is.na(trim_prop_gf))

nrow(artis_trimmings_info_to_fix_3) + nrow(artis_trimmings_aquaculture_gf) + nrow(artis_trimmings_all_info_1) == nrow(artis_trimmings_all) # TRUE good

artis_trimmings_all_info_2 <- artis_trimmings_all_info_1 %>%
  rbind(., artis_trimmings_aquaculture_gf %>% dplyr::select(colnames(artis_trimmings_all_info)))

# how much did that fill in?
artis_trimmings_aquaculture_gf %>% 
  filter(year == 2020) %>%
  pull(product_weight_t) %>%
  sum()/fm_artis %>% filter(year == 2020) %>% pull(product_weight_t) %>% sum() # 0.3302463; gapfilling with aquaculture filled in ~1/3 of fishmeal for 2020! Pretty good! So now we are up to 40+33 = 73% filled in

```
 

Let's see how much info we fill by gapfilling with species level means 
 - RESULT: This fills ~8% of fishmeal without info for 2020
 
Let's apply this one first

```{r}
fm_origins_sciname <- read.csv(here("outputs/all_fmfo_material_origins_literature.csv")) %>%
  dplyr::select(-common_name) %>%
  group_by(sciname, capture) %>%
  summarise(trim_prop = mean(trim_prop, na.rm = TRUE)) %>%
  ungroup()

mean_reports_lit_sciname <- fm_origins_traded %>%
  group_by(sciname, capture) %>%
  summarise(trim_prop = mean(trim_prop, na.rm = TRUE)) %>%
  ungroup() %>%
  rbind(., fm_origins_sciname) %>%
  group_by(sciname, capture) %>%
  summarise(trim_prop_sciname_gf = mean(trim_prop, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(method_new = ifelse(capture == "yes", "capture", "aquaculture")) %>%
  dplyr::select(-capture)

artis_trimmings_sciname_joined <- artis_trimmings_info_to_fix_3 %>%
  left_join(mean_reports_lit_sciname)


artis_trimmings_sciname_gf <- artis_trimmings_sciname_joined %>%
  mutate(trim_prop_gf = ifelse(is.na(trim_prop), trim_prop_sciname_gf, trim_prop)) %>%
  filter(!is.na(trim_prop_gf)) %>%
  mutate(method_trim_gf = "Average trimmings proportion of species from literature and reports") 


artis_trimmings_info_to_fix_4 <- artis_trimmings_sciname_joined %>%
  filter(is.na(trim_prop_sciname_gf))

nrow(artis_trimmings_info_to_fix_4) + nrow(artis_trimmings_sciname_gf) + nrow(artis_trimmings_all_info_2) == nrow(artis_trimmings_all) # TRUE good

artis_trimmings_all_info_3 <- artis_trimmings_all_info_2 %>%
  rbind(., artis_trimmings_sciname_gf %>% dplyr::select(colnames(artis_trimmings_all_info)))


# fills around 30% of the rows
artis_trimmings_all_info_3 %>% 
  filter(year == 2020) %>%
  pull(product_weight_t) %>%
  sum()/fm_artis %>% filter(year == 2020) %>% pull(product_weight_t) %>% sum() # 0.8147685 now we are at 81% filled, meaning the species level means filled 81-73 = ~8% approximately of fishmeal in 2020

```

 
Let's see how much we gapfill by matching the trade flows of fillets 
We gapfill based on any species that is filleted and share the same source country AND exporter country (we assume source and exporter, so that we know that the fish would be processed in the same place, and in theory, this could be the same fish) and year, and calculate the proportion of the fishmeal which is trimmings, based on the amount of trimmings derived from the fillets (for species that don't already have info). I.e., we calculate the leftover trimmings (and convert to fishmeal weight), and divide that by the fishmeal weight reported in ARTIS, to get the proportion of the fishmeal with that combination of year, source country, exporter, and sciname that is trimmings (trim_prop).

 - RESULT: This fills ~9% of fishmeal without info for 2020

```{r}
fillet_data <- fillet_artis %>% 
  group_by(year, source_country_iso3c, exporter_iso3c, sciname, method, habitat) %>%
  summarise(fillet_tonnes_lw = sum(live_weight_t, na.rm = TRUE),
            fillet_tonnes_pw = sum(product_weight_t, na.rm = TRUE)) %>%
  ungroup() %>%
  mutate(filleted = "yes",
         conversion = fillet_tonnes_pw/fillet_tonnes_lw,
         potential_trimmings_lw_t = fillet_tonnes_lw - fillet_tonnes_pw) %>%
  mutate(potential_trimmings_pw_t = (potential_trimmings_lw_t/2.975)*0.96)## account for processing and blood loss of weight??

trimmings_for_fillet_gf <- artis_trimmings_info_to_fix_4 %>%
  group_by(year, source_country_iso3c, exporter_iso3c, sciname, method, habitat) %>%
    summarise(fm_tonnes_lw = sum(live_weight_t, na.rm = TRUE),
            fm_tonnes_pw = sum(product_weight_t, na.rm = TRUE)) %>%
  ungroup() %>%
  left_join(fillet_data) %>%
  filter(!is.na(filleted)) %>%
  mutate(trim_prop_fillet = potential_trimmings_pw_t/fm_tonnes_pw) %>%
  mutate(trim_prop_fillet = ifelse(trim_prop_fillet > 1, 1, trim_prop_fillet)) %>%
  dplyr::select(year, source_country_iso3c, exporter_iso3c, sciname, method, habitat, trim_prop_fillet)
  
# join data
artis_trimmings_fillet_join <- artis_trimmings_info_to_fix_4 %>%
 left_join(trimmings_for_fillet_gf) # join by year, source, exporter, sciname, method, habitat

nrow(artis_trimmings_fillet_join) == nrow(artis_trimmings_info_to_fix_4) # TRUE

artis_trimmings_fillet_fix <- artis_trimmings_fillet_join %>%
    mutate(trim_prop_gf = ifelse(!is.na(trim_prop_fillet), trim_prop_fillet, trim_prop)) %>%
  filter(!is.na(trim_prop_gf)) %>%
  mutate(method_trim_gf = "Used fillet data to determine proportion of fishmeal which is trimmings") %>%
  dplyr::select(colnames(artis_trimmings_all_info))
  
artis_trimmings_fillet_fix %>% 
  filter(year == 2020) %>%
  pull(product_weight_t) %>%
  sum()/fm_artis %>% filter(year == 2020) %>% pull(product_weight_t) %>% sum() # 0.08993586; Would fill in ~9% of fishmeal data for 2020
  # so that would add up to 81+9 = 90% filled in

artis_trimmings_info_to_fix_5 <- artis_trimmings_fillet_join %>%
  filter(is.na(trim_prop_fillet)) %>%
  mutate(method_trim_gf = NA) %>%
  dplyr::select(colnames(artis_trimmings_all_info))


artis_trimmings_all_info_4 <- artis_trimmings_all_info_3 %>%
  rbind(., artis_trimmings_fillet_fix %>% dplyr::select(colnames(artis_trimmings_all_info)))


## take a look at this
  test <- artis_trimmings_fillet_fix %>%
    filter(method == "aquaculture") # 0 good.
  
  test <- artis_trimmings_fillet_fix %>% 
      mutate(trimmings_pw = trim_prop_gf*product_weight_t,
         wholefish_pw = (1-trim_prop_gf)*product_weight_t)

# take a look at the distribution of values
ggplot(artis_trimmings_fillet_fix) +
  geom_histogram(aes(trim_prop_gf)) +
  theme_bw() +
  labs(x = "Proportion of fishmeal derived from trimmings",
       y = "Distinct species and source country count") # ok good, most of it is close to 1


# Reshape to long format
test_long <- test %>%
  filter(year == 2020) %>%
  select(trimmings_pw, wholefish_pw) %>%
  pivot_longer(cols = everything(),
               names_to = "source",
               values_to = "tonnage") %>%
  mutate(source = ifelse(source == "trimmings_pw", "Trimmings", "Whole fish"))

# Plot
ggplot(test_long, aes(x = source, y = tonnage, fill = source)) +
  geom_bar(stat = "summary", fun = sum) +
  labs(x = "Source", y = "Total Tonnage (t)", title = "Tonnage by Source Type") +
  scale_fill_manual(values = c("Trimmings" = "#46A440", "Whole fish" = "#781211")) +
  theme_minimal() # oof ok... we're saying most of the filleted fish species are actually wholefish using this gapfilling... interesting.


## I wanna plot this with fill by genus or family to see what we are working with. Eye test actually seems to make a lot of sense. Most species are nei or actinopterii larger genus's from Asia, which matches up with assumptions we would make anyways. 

test_long <- artis_trimmings_fillet_fix %>%
  left_join(artis_taxa) %>%
  mutate(trimmings_pw = product_weight_t * trim_prop_gf,
         wholefish_pw = product_weight_t * (1 - trim_prop_gf)) %>%
  select(isscaap, trimmings_pw, wholefish_pw) %>%
  pivot_longer(cols = c(trimmings_pw, wholefish_pw),
               names_to = "source",
               values_to = "tonnage") %>%
  mutate(source = ifelse(source == "trimmings_pw", "Trimmings", "Whole fish")) %>%
  mutate(isscaap = case_when(
    str_detect(isscaap, "Miscellaneous|Multiple")  ~ "NEI",
    TRUE ~ isscaap
  ))

# Step 2: Plot, grouped by family
ggplot(test_long, aes(x = source, y = tonnage, fill = isscaap)) +
  geom_bar(stat = "summary", fun = sum, position = "stack") +
  labs(x = "Source", y = "Total Tonnage (t)", title = "Tonnage by Source Type and Family") +
  theme_minimal() +
  scale_y_continuous(labels = scales::comma) +
  theme(legend.position = "right") # cool, mostly NEI species, which actually makes sense.

```

Gapfill any capture shrimp to be trimmings

```{r}
fmfo_factory_data <- read.csv(here("data/shea_et_al_FMFO/adr6921_Suppl_Excel_v2.csv")) %>%
filter(!is.na(factory_id)) %>%
  mutate(country = str_replace_all(country, "\u00A0", " ")) %>%
  filter(str_detect(comm_name, "shrimp"))
 # probably safe to assume any shrimp is trimmings...

# what happens if we do that? 

shrimp_prawn_species <- artis_taxa %>%
  filter(isscaap == "Shrimps, prawns"|genus %in% c("acetes", "penaeus", "rhynchocinetes", "stenopus", "solenocera", "plesionika", "parapenaeopsis", "pandalus", "nematocarcinus", "haliporoides", "heterocarpus", "lysmata")|family %in% c("squillidae", "penaeidae")|common_name == "marine crabs, shrimps, lobsters nei")

artis_trimmings_shrimp <- artis_trimmings_info_to_fix_5 %>%
  left_join(artis_taxa) %>%
  mutate(trim_prop_gf = ifelse(is.na(trim_prop_gf) & sciname %in% c(unique(shrimp_prawn_species$sciname)), 1, trim_prop_gf)) %>%
  dplyr::select(colnames(artis_trimmings_info_to_fix_5))

nrow(artis_trimmings_shrimp) == nrow(artis_trimmings_info_to_fix_5)

artis_trimmings_shrimp_gf <- artis_trimmings_shrimp %>%
    filter(!is.na(trim_prop_gf)) %>%
     mutate(method_trim_gf = "Assuming trimmings because these are shrimp or prawn") 


artis_trimmings_info_to_fix_6 <- artis_trimmings_shrimp %>%
  filter(is.na(trim_prop_gf)) %>%
  dplyr::select(colnames(artis_trimmings_all_info))

nrow(artis_trimmings_info_to_fix_6) + nrow(artis_trimmings_shrimp_gf) + nrow(artis_trimmings_all_info_4) == nrow(artis_trimmings_all) # TRUE good

artis_trimmings_all_info_5 <- artis_trimmings_all_info_4 %>%
  rbind(., artis_trimmings_shrimp_gf %>% dplyr::select(colnames(artis_trimmings_all_info)))

# how much did that fill in?
artis_trimmings_shrimp_gf %>% 
  filter(year == 2020) %>%
  pull(product_weight_t) %>%
  sum()/fm_artis %>% filter(year == 2020) %>% pull(product_weight_t) %>% sum() # 0.0305813; gapfilling with aquaculture filled in 3% of fishmeal for 2020! So now we are up to 93% filled in

# how much did that fill in?
artis_trimmings_all_info_5 %>% 
  filter(year == 2020) %>%
  pull(product_weight_t) %>%
  sum()/fm_artis %>% filter(year == 2020) %>% pull(product_weight_t) %>% sum() # 0.9352856; ~94% filled in

```

Now we apply the same logic as shrimp, but for squids and octopus:

```{r}
fmfo_factory_data <- read.csv(here("data/shea_et_al_FMFO/adr6921_Suppl_Excel_v2.csv")) %>%
filter(!is.na(factory_id)) %>%
  filter(str_detect(comm_name, "squid|Squid|Octopus|cepha"))
 # probably safe to assume any cephalopoda is trimmings...


cephalopod_species <- artis_taxa %>%
  filter(isscaap == "Squids, cuttlefishes, octopuses")

artis_trimmings_squid <- artis_trimmings_info_to_fix_6 %>%
  left_join(artis_taxa) %>%
  mutate(trim_prop_gf = ifelse(is.na(trim_prop_gf) & sciname %in% c(unique(cephalopod_species$sciname)), 1, trim_prop_gf)) %>%
  dplyr::select(colnames(artis_trimmings_info_to_fix_6))

nrow(artis_trimmings_squid) == nrow(artis_trimmings_info_to_fix_6)

artis_trimmings_squid_gf <- artis_trimmings_squid %>%
    filter(!is.na(trim_prop_gf)) %>%
     mutate(method_trim_gf = "Assuming trimmings because these are squids, octopus, or cuttlefish") 


artis_trimmings_info_to_fix_6 <- artis_trimmings_squid %>%
  filter(is.na(trim_prop_gf)) %>%
  dplyr::select(colnames(artis_trimmings_all_info))

nrow(artis_trimmings_info_to_fix_6) + nrow(artis_trimmings_squid_gf) + nrow(artis_trimmings_all_info_5) == nrow(artis_trimmings_all) # TRUE good

artis_trimmings_all_info_5 <- artis_trimmings_all_info_5 %>%
  rbind(., artis_trimmings_squid_gf %>% dplyr::select(colnames(artis_trimmings_all_info)))

# how much did that fill in?
artis_trimmings_squid_gf %>% 
  filter(year == 2020) %>%
  pull(product_weight_t) %>%
  sum()/fm_artis %>% filter(year == 2020) %>% pull(product_weight_t) %>% sum() # 0.008889558; gapfilling with squid filled in 0.8% of fishmeal for 2020! 

# how much did that fill in?
artis_trimmings_all_info_5 %>% 
  filter(year == 2020) %>%
  pull(product_weight_t) %>%
  sum()/fm_artis %>% filter(year == 2020) %>% pull(product_weight_t) %>% sum() # 0.9441752; ~94% filled in

```


Ok, from here we will save what we have gapfilled so far (93% of fishmeal for 2020), then gapfill with price information. If any are still missing after gapfilling with prices, we will do a genus level gapfill. 

Save the data we have gapfilled so far

```{r}

artis_trimmings_all_gf <- artis_trimmings_all_info_5 %>%
  rbind(artis_trimmings_info_to_fix_6)

nrow(artis_trimmings_all_gf) == nrow(artis_trimmings_all) # TRUE

qs::qsave(artis_trimmings_all_gf, file.path(artis_dir, "artis_exchange/artis_fishmeal_trimmings_simple_gf_traded_consumption.qs"))

```


Some testing to make sure things ran ok 

```{r}
trim_gf <- qs::qread(file.path(artis_dir, "artis_exchange/artis_fishmeal_trimmings_simple_gf_traded_consumption.qs"))

summary <- trim_gf %>%
  filter(year == 2020) %>%
  group_by(method_trim_gf) %>%
  summarise(tonnes_prod_gf = sum(product_weight_t, na.rm = TRUE),
            spp = n_distinct(sciname),
            iso3c = n_distinct(source_country_iso3c)) %>%
  ungroup() %>%
  mutate(prop = tonnes_prod_gf/sum(tonnes_prod_gf))


test_all <- trim_gf %>%
  filter(year == 2020) 

sum(test_all$product_weight_t) # 6158133
sum(test_all$trim_product, na.rm = TRUE) + sum(test_all$wholefish_product, na.rm = TRUE) # 5696824

5696824/6158133
# only missing ~7.5% now 
```



```{r}

## lets do some testing
test_crustacean <- artis_trimmings_gf %>% 
 # filter(year == 2020) %>%
  filter(isscaap %in% c("Shrimps, prawns", "Lobsters, spiny-rock lobsters", "King crabs, squat-lobsters") | common_name %in% c("squillids nei", "stomatopods nei", "west african geryon") | str_detect(common_name, "crab|shrimp|squillid") |  genus %in% c("geryon", "scylla")) 

sum(test_crustacean$product_weight_t)/sum(artis_trimmings_all$product_weight_t) # 0.1384497

test_shrimp <- artis_trimmings_gf %>%
 # filter(year == 2020) %>%
  filter(isscaap %in% c("Shrimps, prawns") | str_detect(common_name, "shrimp"))
sum(test_shrimp$product_weight_t)/sum(artis_trimmings_all$product_weight_t) # 0.1156375

test_mollusc <- artis_trimmings_gf %>%
 # filter(year == 2020) %>%
  filter(isscaap %in% c("Abalones, winkles, conchs", "Clams, cockles, arkshells", "Multiple ISSCAAP groups", "Mussels", "Oysters", "Scallops, pectens") & phylum == "mollusca" & !str_detect(common_name, "abalone|barnacle|octopus|squid"))

test2 <- artis_trimmings_all %>%
 # filter(year == 2020) %>%
  pull(product_weight_t) %>%
  sum()

sum(test_mollusc$product_weight_t)/test2 # 0.2013136

test <- artis_trimmings_all %>%
  group_by(phylum, year) %>%
  summarise(tonnes = sum(product_weight_t, na.rm = TRUE)) %>%
  ungroup() %>%
  group_by(year) %>%
  mutate(total_tonnes = sum(tonnes, na.rm = TRUE)) %>%
  mutate(prop = tonnes/total_tonnes) ## cool, checks out. Will probably make more sense to report numbers for 2020 in the actual paper, but global across all years will do for exploration purposes

# what are we still missing?
test <- artis_trimmings_all_gf %>%
  filter(is.na(trim_prop_gf)) %>%
  group_by(phylum) %>%
  summarise(tonnes  = sum(product_weight_t, na.rm = TRUE)) %>%
  ungroup() # ok, need to figure out what to do about echinodermata and cnidaria; chordata is expected to have a lot of gaps.

test <- artis_trimmings_all_gf %>% 
  filter(is.na(trim_prop_gf)) %>%
  filter(phylum %in% c("echinodermata", "cnidaria"))
unique(test$common_name)
#  [1] "sea urchins nei"            "chilean sea urchin"         "sea cucumbers nei"          "starfishes nei"            
#  [5] "echinoderms"                "stony sea urchin"           "european edible sea urchin" "japanese sea cucumber"     
#  [9] "white teatfish"             "prickly redfish"            ""                           "sea urchins, etc. nei"     
# [13] "cannonball jellyfish"       "royal cucumber"             "brown mottled sea cucumber" "red starfish"              
# [17] "black sea urchin"   
# we are removing most of these from our analysis, so we likely don't need to worry about this.


```

